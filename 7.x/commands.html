
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>명령과 그룹 &#8212; 클릭 문서 (7.x)</title>
    <link rel="stylesheet" href="_static/click.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="shortcut icon" href="_static/click-icon.png"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="사용자 입력 프롬프트" href="prompts.html" />
    <link rel="prev" title="인자" href="arguments.html" />
  <script>DOCUMENTATION_OPTIONS.URL_ROOT = './';</script>
   
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="prompts.html" title="사용자 입력 프롬프트"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="arguments.html" title="인자"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">클릭 문서 (7.x)</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1>명령과 그룹<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>클릭의 가장 중요한 기능은 명령행 도구들로 마음대로 계층 구조를
만들 수 있다는 것이다. <a class="reference internal" href="api.html#click.Command" title="click.Command"><code class="xref py py-class docutils literal notranslate"><span class="pre">Command</span></code></a>와 <a class="reference internal" href="api.html#click.Group" title="click.Group"><code class="xref py py-class docutils literal notranslate"><span class="pre">Group</span></code></a>
(<a class="reference internal" href="api.html#click.MultiCommand" title="click.MultiCommand"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiCommand</span></code></a>)를 통해 구현한다.</p>
<div class="section" id="id2">
<h2>콜백 호출<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>일반 명령에서는 명령이 실행될 때마다 콜백이 실행된다. 스크립트에
명령이 유일하면 매번 호출된다. (매개변수 콜백에서 막는 경우는
예외다. 예를 들어 스크립트에 <code class="docutils literal notranslate"><span class="pre">--help</span></code>를 주는 경우가 그렇다.)</p>
<p>그룹 및 다중 명령에서는 상황이 달라진다. 그 경우에는 (동작 방식을
바꾸지 않았다면) 하위 명령이 불릴 때마다 콜백이 불린다. 이게
무슨 뜻이냐면 내부 명령이 실행될 때 외부 명령도 실행된다는 것이다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@click</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="nd">@click</span><span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s1">&#39;--debug/--no-debug&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cli</span><span class="p">(</span><span class="n">debug</span><span class="p">):</span>
    <span class="n">click</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="s1">&#39;Debug mode is </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;on&#39;</span> <span class="k">if</span> <span class="n">debug</span> <span class="k">else</span> <span class="s1">&#39;off&#39;</span><span class="p">))</span>

<span class="nd">@cli</span><span class="o">.</span><span class="n">command</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">sync</span><span class="p">():</span>
    <span class="n">click</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="s1">&#39;Syncing&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>다음처럼 된다.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ tool.py
Usage: tool.py [OPTIONS] COMMAND [ARGS]...

Options:
  --debug / --no-debug
  --help                Show this message and exit.

Commands:
  sync

$ tool.py --debug sync
Debug mode is on
Syncing
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>매개변수 전달<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>클릭에서는 명령과 하위 명령 간에 매개변수를 엄격하게 구분한다.
이게 무슨 뜻이냐면 어떤 명령에 대한 옵션과 인자는 그 명령 이름
<em>뒤에</em>, 그리고 다음 명령이 있다면 그 명령 이름 <em>앞에</em> 지정해야
한다는 것이다.</p>
<p>이미 정의돼 있는 <code class="docutils literal notranslate"><span class="pre">--help</span></code> 옵션에서도 이 동작을 볼 수 있다.
가령 <code class="docutils literal notranslate"><span class="pre">tool.py</span></code>라는 프로그램이 있고 거기에 <code class="docutils literal notranslate"><span class="pre">sub</span></code>라는
하위 명령이 있다고 하자.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tool.py</span> <span class="pre">--help</span></code>라고 하면 프로그램 전체의 (하위 명령들을
나열하는) 도움말이 나온다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tool.py</span> <span class="pre">sub</span> <span class="pre">--help</span></code>라고 하면 하위 명령 <code class="docutils literal notranslate"><span class="pre">sub</span></code>의 도움말이
나온다.</p></li>
<li><p>하지만 <code class="docutils literal notranslate"><span class="pre">tool.py</span> <span class="pre">--help</span> <span class="pre">sub</span></code>라고 하면 <code class="docutils literal notranslate"><span class="pre">--help</span></code>를 주
프로그램의 인자로 취급한다. 그럼 클릭에서 <code class="docutils literal notranslate"><span class="pre">--help</span></code>의 콜백을
호출하고, 그러면 도움말을 찍고서 프로그램 실행을 중단한다.
그래서 하위 명령은 처리하지 못한다.</p></li>
</ul>
</div>
<div class="section" id="id4">
<h2>계층 처리와 문맥<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>앞선 예에서 볼 수 있듯 기본 명령 그룹은 콜백으로 전달되는 debug
인자를 받지만 sync 명령은 받지 못한다. sync 명령은 자체 인자만
받는다.</p>
<p>덕분에 도구들이 서로 완전히 독립적으로 동작할 수 있다. 하지만
어떤 명령에서 하위 명령으로 뭔가를 전달하려면 어떡해야 할까?
답은 <a class="reference internal" href="api.html#click.Context" title="click.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a>다.</p>
<p>명령이 호출될 때마다 새 문맥이 생성돼서 부모 문맥에 연결된다.
보통은 그 문맥들을 볼 수 없지만 분명 그렇게 존재한다.
문맥은 매개변수 콜백에 자동으로 값과 함께 전달된다.
그리고 명령에서도 <a class="reference internal" href="api.html#click.pass_context" title="click.pass_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">pass_context()</span></code></a> 데코레이터로 표시를
해서 문맥을 전달받을 수 있다. 그 경우 문맥이 첫 번째 인자로
전달된다.</p>
<p>프로그램 자체 용도를 위해 프로그램에서 지정한 객체를 문맥이
가지고 있을 수 있다. 즉 다음처럼 스크립트를 만들 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@click</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="nd">@click</span><span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s1">&#39;--debug/--no-debug&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="nd">@click</span><span class="o">.</span><span class="n">pass_context</span>
<span class="k">def</span> <span class="nf">cli</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">debug</span><span class="p">):</span>
    <span class="c1"># ctx.obj가 존재하는지, 그리고 dict인지 (아래의 `if` 블록</span>
    <span class="c1"># 아닌 경로로 `cli()`가 호출되는 경우 대비) 확인한다</span>
    <span class="n">ctx</span><span class="o">.</span><span class="n">ensure_object</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

    <span class="n">ctx</span><span class="o">.</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;DEBUG&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">debug</span>

<span class="nd">@cli</span><span class="o">.</span><span class="n">command</span><span class="p">()</span>
<span class="nd">@click</span><span class="o">.</span><span class="n">pass_context</span>
<span class="k">def</span> <span class="nf">sync</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
    <span class="n">click</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="s1">&#39;Debug is </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;DEBUG&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="s1">&#39;on&#39;</span> <span class="ow">or</span> <span class="s1">&#39;off&#39;</span><span class="p">))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">cli</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="p">{})</span>
</pre></div>
</div>
<p>객체가 제공되면 각 문맥에서 그 객체를 자식들로 계속 전달한다.
단 어느 단계에서든 문맥의 객체를 바꿀 수 있다. 부모 문맥에
접근하려면 <code class="docutils literal notranslate"><span class="pre">context.parent</span></code>를 이용하면 된다.</p>
<p>추가로, 객체를 내려 주는 방식 대신 응용에서 전역 상태를 변경하는
것도 얼마든 가능하다. 예를 들어 그냥 전역의 <code class="docutils literal notranslate"><span class="pre">DEBUG</span></code> 변수를
바꾸는 식으로 할 수도 있다.</p>
</div>
<div class="section" id="id5">
<h2>명령 데코레이터<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>앞선 예에서 본 것처럼 데코레이터를 써서 명령이 호출되는 방식을
바꿀 수 있다. 배후에서 실제 일어나는 동작은 콜백은 항상
<a class="reference internal" href="api.html#click.Context.invoke" title="click.Context.invoke"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Context.invoke()</span></code></a> 메소드를 통해 호출되고 그 메소드에서
자동으로 명령을 올바르게 (문맥을 전달하며, 또는 하지 않으며)
호출하는 것이다.</p>
<p>이게 유용한 건 새로운 데코레이터를 작성하고 싶을 때다. 예를 들어
흔한 패턴으로 상태를 나타내는 객체를 구성해서 문맥에 저장해 둔
다음 새로운 데코레이터를 사용해 그런 최근 객체를 첫 번째 인자로
전달해 주는 방식이 있다.</p>
<p>예를 들어 <a class="reference internal" href="api.html#click.pass_obj" title="click.pass_obj"><code class="xref py py-func docutils literal notranslate"><span class="pre">pass_obj()</span></code></a> 데코레이터를 다음처럼 구현할 수 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">update_wrapper</span>

<span class="k">def</span> <span class="nf">pass_obj</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="nd">@click</span><span class="o">.</span><span class="n">pass_context</span>
    <span class="k">def</span> <span class="nf">new_func</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ctx</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ctx</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">update_wrapper</span><span class="p">(</span><span class="n">new_func</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="api.html#click.Context.invoke" title="click.Context.invoke"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Context.invoke()</span></code></a>에서 함수를 올바른 방식으로 호출해 준다.
즉 <a class="reference internal" href="api.html#click.pass_context" title="click.pass_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">pass_context()</span></code></a>로 꾸며 줬는지 여부에 따라 함수가
<code class="docutils literal notranslate"><span class="pre">f(ctx,</span> <span class="pre">obj)</span></code>나 <code class="docutils literal notranslate"><span class="pre">f(obj)</span></code> 중 하나로 호출된다.</p>
<p>이 강력한 개념을 이용하면 아주 복잡한 중첩 응용을 만들 수 있다.
자세한 내용은 <a class="reference internal" href="complex.html#complex-guide"><span class="std std-ref">복잡한 응용</span></a> 참고.</p>
</div>
<div class="section" id="id6">
<h2>명령 없이 그룹 호출하기<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>기본적으로 그룹 내지 다중 명령은 하위 명령을 주지 않는 한 호출되지
않는다. 실제로 명령을 주지 않으면 기본적으로 <code class="docutils literal notranslate"><span class="pre">--help</span></code>가 자동으로
들어간다. 이 동작 방식을 바꾸려면 그룹에
<code class="docutils literal notranslate"><span class="pre">invoke_without_command=True</span></code>를 주면 된다. 그러면 도움말
페이지를 보이는 대신 항상 콜백을 호출한다. 그리고 문맥 객체에는
호출이 하위 명령으로 가게 되는지 여부에 대한 정보가 있다.</p>
<p>예:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@click</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">invoke_without_command</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nd">@click</span><span class="o">.</span><span class="n">pass_context</span>
<span class="k">def</span> <span class="nf">cli</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">ctx</span><span class="o">.</span><span class="n">invoked_subcommand</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">click</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="s1">&#39;I was invoked without subcommand&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">click</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="s1">&#39;I am about to invoke </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">ctx</span><span class="o">.</span><span class="n">invoked_subcommand</span><span class="p">)</span>

<span class="nd">@cli</span><span class="o">.</span><span class="n">command</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">sync</span><span class="p">():</span>
    <span class="n">click</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="s1">&#39;The subcommand&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>그러면 실제로 다음처럼 된다.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ tool
I was invoked without subcommand
$ tool sync
I am about to invoke sync
The subcommand
</pre></div>
</div>
</div>
<div class="section" id="custom-multi-commands">
<span id="id7"></span><h2>새로운 다중 명령<a class="headerlink" href="#custom-multi-commands" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="api.html#click.group" title="click.group"><code class="xref py py-func docutils literal notranslate"><span class="pre">click.group()</span></code></a>을 쓰는 대신 자체적으로 새로운 다중 명령을
만들 수도 있다. 필요할 때 플러그인의 명령들을 적재하는 걸
지원하려 할 때 유용하다.</p>
<p>새로운 다중 명령에는 나열 메소드와 적재 메소드만 구현해 주면 된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">click</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="n">plugin_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s1">&#39;commands&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MyCLI</span><span class="p">(</span><span class="n">click</span><span class="o">.</span><span class="n">MultiCommand</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">list_commands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">plugin_folder</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.py&#39;</span><span class="p">):</span>
                <span class="n">rv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filename</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">rv</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">rv</span>

    <span class="k">def</span> <span class="nf">get_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">plugin_folder</span><span class="p">,</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.py&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">code</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="n">fn</span><span class="p">,</span> <span class="s1">&#39;exec&#39;</span><span class="p">)</span>
            <span class="nb">eval</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">ns</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ns</span><span class="p">[</span><span class="s1">&#39;cli&#39;</span><span class="p">]</span>

<span class="n">cli</span> <span class="o">=</span> <span class="n">MyCLI</span><span class="p">(</span><span class="n">help</span><span class="o">=</span><span class="s1">&#39;This tool</span><span class="se">\&#39;</span><span class="s1">s subcommands are loaded from a &#39;</span>
            <span class="s1">&#39;plugin folder dynamically.&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">cli</span><span class="p">()</span>
</pre></div>
</div>
<p>이 새 클래스를 데코레이터에 쓸 수도 있다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@click</span><span class="o">.</span><span class="n">command</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="n">MyCLI</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cli</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>다중 명령 병합<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>새로운 다중 명령을 구현하는 것에 못지 않게 여러 스크립트를
하나로 합치는 것도 눈여겨볼 만하다. 일반적으로는 한쪽을
다른 쪽 아래 두는 방식을 더 권장하지만 어떤 경우에는
합치는 방식을 써서 더 편한 셸 사용 경험을 제공할 수 있다.</p>
<p>그런 병합 방식의 기본 구현체가 <a class="reference internal" href="api.html#click.CommandCollection" title="click.CommandCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">CommandCollection</span></code></a>
클래스다. 다른 다중 명령들의 목록을 받아서 그 명령들을
같은 단계에서 사용할 수 있게 만들어 준다.</p>
<p>사용례:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">click</span>

<span class="nd">@click</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">cli1</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="nd">@cli1</span><span class="o">.</span><span class="n">command</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">cmd1</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Command on cli1&quot;&quot;&quot;</span>

<span class="nd">@click</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">cli2</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="nd">@cli2</span><span class="o">.</span><span class="n">command</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">cmd2</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Command on cli2&quot;&quot;&quot;</span>

<span class="n">cli</span> <span class="o">=</span> <span class="n">click</span><span class="o">.</span><span class="n">CommandCollection</span><span class="p">(</span><span class="n">sources</span><span class="o">=</span><span class="p">[</span><span class="n">cli1</span><span class="p">,</span> <span class="n">cli2</span><span class="p">])</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">cli</span><span class="p">()</span>
</pre></div>
</div>
<p>그러면 다음처럼 된다.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ cli --help
Usage: cli [OPTIONS] COMMAND [ARGS]...

Options:
  --help  Show this message and exit.

Commands:
  cmd1  Command on cli1
  cmd2  Command on cli2
</pre></div>
</div>
<p>한 명령이 여러 곳에 존재하는 경우에는 처음 나오는 곳의 명령을 쓴다.</p>
</div>
<div class="section" id="multi-command-chaining">
<span id="id9"></span><h2>다중 명령 연속 지정<a class="headerlink" href="#multi-command-chaining" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.0.</span></p>
</div>
<p>한 번에 여러 하위 명령을 호출하는 게 가능하면 좋을 때가 있다.
예를 들어 이전에 setuptools 패키지를 설치해 본 적이 있다면
<code class="docutils literal notranslate"><span class="pre">setup.py</span> <span class="pre">sdist</span> <span class="pre">bdist_wheel</span> <span class="pre">upload</span></code>라는 연속 명령에 익숙할
것이다. 이 명령은 <code class="docutils literal notranslate"><span class="pre">sdist</span></code> 다음에 <code class="docutils literal notranslate"><span class="pre">bdist_wheel</span></code>을, 그리고
<code class="docutils literal notranslate"><span class="pre">upload</span></code>를 차례로 호출한다. 클릭 3.0부터는 이걸 아주
간편하게 구현할 수 있다. 다중 명령에 <code class="docutils literal notranslate"><span class="pre">chain=True</span></code>를
주기만 하면 된다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@click</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">chain</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cli</span><span class="p">():</span>
    <span class="k">pass</span>


<span class="nd">@cli</span><span class="o">.</span><span class="n">command</span><span class="p">(</span><span class="s1">&#39;sdist&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sdist</span><span class="p">():</span>
    <span class="n">click</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="s1">&#39;sdist called&#39;</span><span class="p">)</span>


<span class="nd">@cli</span><span class="o">.</span><span class="n">command</span><span class="p">(</span><span class="s1">&#39;bdist_wheel&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">bdist_wheel</span><span class="p">():</span>
    <span class="n">click</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="s1">&#39;bdist_wheel called&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>그러면 다음처럼 호출할 수 있다.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ setup.py sdist bdist_wheel
sdist called
bdist_wheel called
</pre></div>
</div>
<p>연속 다중 명령 방식을 쓸 때는 (마지막의) 한 명령에서만 인자에
<code class="docutils literal notranslate"><span class="pre">nargs=-1</span></code>을 쓸 수 있다. 또한 연속 다중 명령 아래에 다른 다중
명령을 넣는 게 불가능하다. 그 외에는 동작 방식에 어떤 제약도 없다.
다른 경우들처럼 옵션과 인자를 받을 수 있다.</p>
<p>추가 참고 사항: 다중 명령에서 여러 명령을 호출할 때는
<a class="reference internal" href="api.html#click.Context.invoked_subcommand" title="click.Context.invoked_subcommand"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Context.invoked_subcommand</span></code></a> 속성에 <code class="docutils literal notranslate"><span class="pre">'*'</span></code> 값이
들어가므로 별 쓸모가 없다. 이는 하위 명령 처리가 하나씩 차례로
이뤼지기 때문에 콜백 발화 때는 정확히 어떤 하위 명령들이
처리될지 알 수 없기 때문이다.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>현재는 연속 명령들에 하위 명령을 넣는 게 불가능하다. 클릭
향후 버전에서 고쳐질 예정이다.</p>
</div>
</div>
<div class="section" id="id10">
<h2>다중 명령 파이프라인<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.0.</span></p>
</div>
<p>연속 다중 명령을 사용하는 아주 흔한 경우는 한 명령이 앞 명령의
결과를 처리하게 하는 것이다. 이를 가능하게 해 주는 방법이
여러 가지 있다. 쉽게 떠오르는 걸로는 문맥 객체에 값을 저장해서
함수를 넘나들며 그 값을 처리하는 방법이 있다. 함수를
<a class="reference internal" href="api.html#click.pass_context" title="click.pass_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">pass_context()</span></code></a>로 꾸며 주면 문맥 객체가 제공되므로
하위 명령에서 거기에 데이터를 저장할 수 있게 된다.</p>
<p>또 다른 방법은 처리 함수를 반환하게 해서 파이프라인을 구성하는
것이다. 말하자면, 하위 명령을 호출하면 거기선 매개변수들을 모두
처리하고서 어떻게 처리를 수행할지 계획을 세운다. 그러고 나면
그 처리 함수를 반환하며 돌아오는 것이다.</p>
<p>그럼 반환된 그 함수들은 어디로 가는 걸까? 연속 다중 명령에서는
<a class="reference internal" href="api.html#click.MultiCommand.resultcallback" title="click.MultiCommand.resultcallback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiCommand.resultcallback()</span></code></a>으로 콜백을 등록할 수 있는데
거기서 그 함수들을 모두 훑으며 호출한다.</p>
<p>좀 더 구체적으로 보자면 다음 예를 생각해 보자.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@click</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">chain</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">invoke_without_command</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nd">@click</span><span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s1">&#39;-i&#39;</span><span class="p">,</span> <span class="s1">&#39;--input&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">click</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">cli</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nd">@cli</span><span class="o">.</span><span class="n">resultcallback</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">process_pipeline</span><span class="p">(</span><span class="n">processors</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
    <span class="n">iterator</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">input</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">processor</span> <span class="ow">in</span> <span class="n">processors</span><span class="p">:</span>
        <span class="n">iterator</span> <span class="o">=</span> <span class="n">processor</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
        <span class="n">click</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

<span class="nd">@cli</span><span class="o">.</span><span class="n">command</span><span class="p">(</span><span class="s1">&#39;uppercase&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">make_uppercase</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">processor</span><span class="p">(</span><span class="n">iterator</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">line</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">processor</span>

<span class="nd">@cli</span><span class="o">.</span><span class="n">command</span><span class="p">(</span><span class="s1">&#39;lowercase&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">make_lowercase</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">processor</span><span class="p">(</span><span class="n">iterator</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">line</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">processor</span>

<span class="nd">@cli</span><span class="o">.</span><span class="n">command</span><span class="p">(</span><span class="s1">&#39;strip&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">make_strip</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">processor</span><span class="p">(</span><span class="n">iterator</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">processor</span>
</pre></div>
</div>
<p>설명할 게 좀 많다. 하나씩 살펴보자.</p>
<ol class="arabic simple">
<li><p>첫 번째로 할 일은 명령 연속 지정이 가능한 <a class="reference internal" href="api.html#click.group" title="click.group"><code class="xref py py-func docutils literal notranslate"><span class="pre">group()</span></code></a>을
만드는 것이다. 그리고 하위 명령이 지정되지 않더라도 클릭에서
호출하도록 한다. 이렇게 하지 않으면 빈 파이프라인 호출 시에
결과 콜백을 실행하는 대신 도움말 페이지를 내놓게 된다.</p></li>
<li><p>다음으로 할 일은 그룹에 결과 콜백을 등록하는 것이다. 그러면
모든 하위 명령의 반환 값들, 그리고 그룹 자체가 받은 것과
같은 키워드 매개변수들을 인자로 해서 그 콜백이 호출된다.
즉 문맥 객체를 쓰지 않아도 거기서 입력 파일에 쉽게 접근할
수 있다.</p></li>
<li><p>그 결과 콜백 내에서는 입력 파일의 모든 행으로 이터레이터를
만들고 하위 명령에서 반환한 콜백 모두를 이터레이터가 거치게
하고서 모든 행을 stdout으로 찍는다.</p></li>
</ol>
<p>이렇게 한 다음에는 원하는 대로 하위 명령들을 등록할 수 있으며
각 하위 명령에서는 행 스트림을 변경하는 처리 함수를 반환하면 된다.</p>
<p>주의할 점 하나는 각 콜백이 실행된 후에 클릭에서 문맥을 없앤다는
것이다. 그래서 예를 들면 파일 타입을 <cite>processor</cite> 함수 안에서
접근할 수 없다. 거기선 파일이 이미 닫혀 있기 때문이다.
이런 제약은 자원 관리를 훨씬 단순하게 해 주기 때문에 아마
바뀌지 않을 것이다. 따라서 파일 타입을 쓰는 대신 직접
<a class="reference internal" href="api.html#click.open_file" title="click.open_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_file()</span></code></a>을 통해 파일을 열기를 권한다.</p>
<p>파이프라인 처리 방식도 개선한 더 복잡한 예를 클릭 저장소의
<a class="reference external" href="https://github.com/pallets/click/tree/master/examples/imagepipe">imagepipe 연속 다중 명령 예시</a>에서
볼 수 있다. 파이프라인 기반으로 이미지 편집 툴을 구현한 것인데
내부 구조가 파이프라인에 잘 맞게 돼 있다.</p>
</div>
<div class="section" id="id11">
<h2>기본값 바꾸기<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<p>기본적으로 매개변수의 기본값은 그 매개변수를 정의할 때 준
<code class="docutils literal notranslate"><span class="pre">default</span></code> 플래그에서 가져오지만 거기서만 가져오는 건
아니다. 문맥의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Context.default_map</span></code>(딕셔너리)에서도
기본값을 가져온다. 이를 이용하면 설정 파일에서 기본값을
읽어 들여서 원래 기본값을 교체할 수 있다.</p>
<p>다른 패키지에서 어떤 명령들을 플러그인 형태로 가져오려는데
기본값은 마음에 들지 않을 때 유용하다.</p>
<p>각 하위 명령에 맞춰 필요한 대로 기본값 맵의 계층을 만들어서
스크립트 호출 시에 제공할 수 있다. 아니면 명령 어느 지점에서든
기본값을 교체할 수도 있다. 예를 들어 최상위 명령에서
설정 파일에 있는 기본값을 읽어 들일 수 있을 것이다.</p>
<p>사용례:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">click</span>

<span class="nd">@click</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">cli</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="nd">@cli</span><span class="o">.</span><span class="n">command</span><span class="p">()</span>
<span class="nd">@click</span><span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s1">&#39;--port&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">8000</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">runserver</span><span class="p">(</span><span class="n">port</span><span class="p">):</span>
    <span class="n">click</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="s1">&#39;Serving on http://127.0.0.1:</span><span class="si">%d</span><span class="s1">/&#39;</span> <span class="o">%</span> <span class="n">port</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">cli</span><span class="p">(</span><span class="n">default_map</span><span class="o">=</span><span class="p">{</span>
        <span class="s1">&#39;runserver&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;port&#39;</span><span class="p">:</span> <span class="mi">5000</span>
        <span class="p">}</span>
    <span class="p">})</span>
</pre></div>
</div>
<p>동작시켜 보면:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ cli runserver
Serving on http://127.0.0.1:5000/
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h2>문맥 기본값<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">New in version 2.0.</span></p>
</div>
<p>클릭 2.0부터는 스크립트를 호출할 때만이 아니라 명령을 선언하는
데코레이터에서도 문맥의 기본값을 교체할 수 있다. 예를 들어
따로 <code class="docutils literal notranslate"><span class="pre">default_map</span></code>을 정의하는 앞선 예가 있을 때 그걸
데코레이터에서도 할 수 있다.</p>
<p>다음 예는 앞의 예와 동일하게 동작한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">click</span>

<span class="n">CONTEXT_SETTINGS</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">default_map</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;runserver&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;port&#39;</span><span class="p">:</span> <span class="mi">5000</span><span class="p">}}</span>
<span class="p">)</span>

<span class="nd">@click</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">context_settings</span><span class="o">=</span><span class="n">CONTEXT_SETTINGS</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cli</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="nd">@cli</span><span class="o">.</span><span class="n">command</span><span class="p">()</span>
<span class="nd">@click</span><span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s1">&#39;--port&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">8000</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">runserver</span><span class="p">(</span><span class="n">port</span><span class="p">):</span>
    <span class="n">click</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="s1">&#39;Serving on http://127.0.0.1:</span><span class="si">%d</span><span class="s1">/&#39;</span> <span class="o">%</span> <span class="n">port</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">cli</span><span class="p">()</span>
</pre></div>
</div>
<p>마찬가지로 동작시켜 보면:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ cli runserver
Serving on http://127.0.0.1:5000/
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h2>명령 반환 값<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.0.</span></p>
</div>
<p>클릭 3.0에서 새로 도입된 것 중 하나는 명령 콜백 반환값을 제대로
지원하는 것이다. 이를 이용하면 이전에는 구현하기 힘들었던 여러
기능들이 가능해진다.</p>
<p>기본적으로 이제 어떤 명령 콜백에서도 값을 반환할 수 있다. 그
반환 값은 특정 수신자에게로 흘러간다. 이를 이용하는 사례를
<a class="reference internal" href="#multi-command-chaining"><span class="std std-ref">다중 명령 연속 지정</span></a>의 예에서 이미 보았다. 거기서
본 것처럼 반환 값들을 연속 다중 명령의 콜백에서 처리할 수 있다.</p>
<p>클릭에서 명령 반환 값을 다룰 때 다음 사항들에 유념해야 한다.</p>
<ul class="simple">
<li><p>일반적으로 <a class="reference internal" href="api.html#click.BaseCommand.invoke" title="click.BaseCommand.invoke"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseCommand.invoke()</span></code></a> 메소드에서는 명령
콜백의 반환 값이 반환된다. 이 규칙에 대한 예외는
<a class="reference internal" href="api.html#click.Group" title="click.Group"><code class="xref py py-class docutils literal notranslate"><span class="pre">Group</span></code></a>과 관련돼 있다.</p>
<ul>
<li><p>그룹에서 반환 값은 일반적으로 호출된 하위 명령의
반환 값이다. 이 규칙의 유일한 예외로 인자 없이 호출됐고
<cite>invoke_without_command</cite>가 켜져 있으면 그룹 콜백의
반환 값이 반환 값이다.</p></li>
<li><p>그룹이 연속 호출 설정이 돼 있으면 모든 하위 명령
결과들의 리스트가 반환 값이다.</p></li>
<li><p>그룹의 반환 값을 <a class="reference internal" href="api.html#click.MultiCommand.result_callback" title="click.MultiCommand.result_callback"><code class="xref py py-attr docutils literal notranslate"><span class="pre">MultiCommand.result_callback</span></code></a>을
통해 처리할 수 있다. 연속 모드에서는 모든 반환 값들의
리스트로, 아닌 경우에는 반환 값 하나로 호출된다.</p></li>
</ul>
</li>
<li><p><a class="reference internal" href="api.html#click.Context.invoke" title="click.Context.invoke"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Context.invoke()</span></code></a> 및 <a class="reference internal" href="api.html#click.Context.forward" title="click.Context.forward"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Context.forward()</span></code></a> 메소드에서
반환 값이 솟아 나온다. 내부적으로 다른 명령을 호출하고
싶은 경우에 유용하다.</p></li>
<li><p>클릭에선 반환 값에 대해 어떤 뚜렷한 요구 조건도 없으며 반환
값을 자체적으로 사용하지 않는다. 그래서 반환 값을 (다중
명령 연속 지정 예시에서와 같은) 자체 데코레이터나 처리
흐름에서 이용하는 게 가능하다.</p></li>
<li><p>클릭 스크립트가 (<a class="reference internal" href="api.html#click.BaseCommand.main" title="click.BaseCommand.main"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseCommand.main()</span></code></a>을 통해) 명령행
응용으로 호출될 때는 그 반환 값이 무시된다. 단
<cite>standalone_mode</cite>가 꺼져 있는 경우에는 전달된다.</p></li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
  <span id="sidebar-top"></span>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  
    
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/click-logo-sidebar.png" alt="Logo"/>
            </a></p>
  

  <h3>Contents</h3>
  <ul>
<li><a class="reference internal" href="#">명령과 그룹</a><ul>
<li><a class="reference internal" href="#id2">콜백 호출</a></li>
<li><a class="reference internal" href="#id3">매개변수 전달</a></li>
<li><a class="reference internal" href="#id4">계층 처리와 문맥</a></li>
<li><a class="reference internal" href="#id5">명령 데코레이터</a></li>
<li><a class="reference internal" href="#id6">명령 없이 그룹 호출하기</a></li>
<li><a class="reference internal" href="#custom-multi-commands">새로운 다중 명령</a></li>
<li><a class="reference internal" href="#id8">다중 명령 병합</a></li>
<li><a class="reference internal" href="#multi-command-chaining">다중 명령 연속 지정</a></li>
<li><a class="reference internal" href="#id10">다중 명령 파이프라인</a></li>
<li><a class="reference internal" href="#id11">기본값 바꾸기</a></li>
<li><a class="reference internal" href="#id12">문맥 기본값</a></li>
<li><a class="reference internal" href="#id13">명령 반환 값</a></li>
</ul>
</li>
</ul>
<h3>Navigation</h3>
<ul>
  <li><a href="index.html">Overview</a>
    <ul>
          <li>Previous: <a href="arguments.html" title="previous chapter">인자</a>
          <li>Next: <a href="prompts.html" title="next chapter">사용자 입력 프롬프트</a>
    </ul>
  </li>
</ul>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014 Pallets Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>

  </body>
</html>